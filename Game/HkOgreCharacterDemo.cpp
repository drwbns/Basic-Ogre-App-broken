/*
-----------------------------------------------------------------------------
Filename:    HkOgreCharacterDemo.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/


#include "HkOgreCharacterDemo.h"
#include "Options.h"
#include "InputActions.h"
#include "IVehicle.h"

#include <Physics/Vehicle/hkpVehicleInstance.h>
#include <Physics/Vehicle/Camera/hkp1dAngularFollowCam.h>
#include <Vehicle/VehicleSetup.h>
#include <Vehicle/VehicleUtils.h>
#include "Common\Visualize\Shape\hkDisplayGeometry.h"

#include <OgreTerrainMaterialGeneratorA.h>

// Used for loading/saving
#include <Physics/Utilities/Serialize/hkpHavokSnapshot.h>
#include <Common/Base/System/Io/Writer/Array/hkArrayStreamWriter.h>
#include <Common/Base/System/Io/Reader/Memory/hkMemoryStreamReader.h>
#include <Common/Base/Reflection/Registry/hkVtableClassRegistry.h>
#include <Common/Base/Reflection/Registry/hkTypeInfoRegistry.h>
#include <Common/Base/System/Stopwatch/hkStopwatch.h>
#include <Demo/Demos/DemoCommon/DemoFramework/hkTextDisplay.h>
#include <Common/Serialize/Util/hkSerializeUtil.h>
#include <Common\Base\System\Io\IStream\hkIStream.h>

#include <Common/Serialize/Packfile/Binary/hkBinaryPackfileWriter.h>
#include <Common/Serialize/Util/hkRootLevelContainer.h>

#include "TerrainMaterialGeneratorD.h"

#include "CharacterOgre.h"

#include "EngineManager.h"

static GameEngine::EngineManager * EngineMgr = GameEngine::EngineManager::getInstance();


//-------------------------------------------------------------------------------------
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    int main(int argc, char *argv[])//INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object and call go()

        HkOgreCharacterDemo app;

        return 0;
    }

#ifdef __cplusplus
}
#endif

//-------------------------------------------------------------------------------------
HkOgreCharacterDemo::HkOgreCharacterDemo(void)
{

	go();
	//createCamera();

	EngineMgr->initHavok();

	// Create the scene
	createScene(true);
	
	

	getRoot()->startRendering();

	// clean up
	destroyScene();
	
}

//-------------------------------------------------------------------------------------
HkOgreCharacterDemo::~HkOgreCharacterDemo(void)
{
	//[NOTE] Always remember to delete any PageLoader(s) and PagedGeometry instances in order to avoid memory leaks.

	//Delete the TreeLoader3D instance
	delete trees->getPageLoader();

	//Delete the PagedGeometry instance
	delete trees;

	//Also delete the tree entity
	getSceneMgr().destroyEntity("Tree");
}


void HkOgreCharacterDemo::getTerrainImage(bool flipX, bool flipY, Ogre::Image& img)
{
	img.load("terrain.png", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	if (flipX)
		img.flipAroundY();
	if (flipY)
		img.flipAroundX();
 
}

hkpBvTreeShape* HkOgreCharacterDemo::loadBVTreeShape(std::string & filename) {
	hkSerializeUtil::ErrorDetails * loadError();
	//loadError.defaultMessage.set("Default Message", 15);
	hkResource * result = hkSerializeUtil::load(filename.c_str());
	//HK_ASSERT(0xa6451543, result, "Could not load file. The error is:\n" << loadError->defaultMessage.cString() );
	if ( result )
		return result->getContents<hkpBvTreeShape>(); 
	else return NULL;
}

void HkOgreCharacterDemo::saveBVTreeShape(const char *filename, hkpBvTreeShape & bvtreeShape) {
			hkStopwatch saveTime;
		{
			saveTime.start();

			hkResult result;
			result = hkSerializeUtil::save(&bvtreeShape, hkpBvTreeShapeClass, hkOstream(filename).getStreamWriter() );
			
			HK_ASSERT2(0xa6451543, result == HK_SUCCESS, "Could not save bvtreeShape" );

			saveTime.stop();
		}
}

void HkOgreCharacterDemo::defineTerrain(long x, long y)
{
	Ogre::String filename = mTerrainGroup->generateFilename(x, y);
	if (Ogre::ResourceGroupManager::getSingleton().resourceExists(mTerrainGroup->getResourceGroup(), filename))
	{
		mTerrainGroup->defineTerrain(x, y);
	}
	else
	{
		Ogre::Image img;
		getTerrainImage(x % 2 != 0, y % 2 != 0, img);
		mTerrainGroup->defineTerrain(x, y, &img);
		mTerrainsImported = true;
	}
}
//-------------------------------------------------------------------------------------
void HkOgreCharacterDemo::initBlendMaps(Ogre::Terrain* terrain)
{
	Ogre::TerrainLayerBlendMap* blendMap0 = terrain->getLayerBlendMap(1);
	Ogre::TerrainLayerBlendMap* blendMap1 = terrain->getLayerBlendMap(2);
	Ogre::Real minHeight0 = 70;
	Ogre::Real fadeDist0 = 40;
	Ogre::Real minHeight1 = 70;
	Ogre::Real fadeDist1 = 15;
	float* pBlend1 = blendMap1->getBlendPointer();
	for (Ogre::uint16 y = 0; y < terrain->getLayerBlendMapSize(); ++y)
	{
		for (Ogre::uint16 x = 0; x < terrain->getLayerBlendMapSize(); ++x)
		{
			Ogre::Real tx, ty;
 
			blendMap0->convertImageToTerrainSpace(x, y, &tx, &ty);
			Ogre::Real height = terrain->getHeightAtTerrainPosition(tx, ty);
			Ogre::Real val = (height - minHeight0) / fadeDist0;
			val = Ogre::Math::Clamp(val, (Ogre::Real)0, (Ogre::Real)1);
 
			val = (height - minHeight1) / fadeDist1;
			val = Ogre::Math::Clamp(val, (Ogre::Real)0, (Ogre::Real)1);
			*pBlend1++ = val;
		}
	}
	blendMap0->dirty();
	blendMap1->dirty();
	blendMap0->update();
	blendMap1->update();
}
//-------------------------------------------------------------------------------------
void HkOgreCharacterDemo::configureTerrainDefaults(Ogre::Light* light)
{
	
	// Configure global
	mTerrainGlobals->setMaxPixelError(1);
	// testing composite map
	mTerrainGlobals->setCompositeMapDistance(3000);
 
	// Important to set these so that the terrain knows what to use for derived (non-realtime) data
	mTerrainGlobals->setLightMapDirection(light->getDerivedDirection());
	mTerrainGlobals->setCompositeMapAmbient(getSceneMgr().getAmbientLight());
	mTerrainGlobals->setCompositeMapDiffuse(light->getDiffuseColour());
 
	// Configure default import settings for if we use imported image
	Ogre::Terrain::ImportData& defaultimp = mTerrainGroup->getDefaultImportSettings();
	defaultimp.terrainSize = 513;
	defaultimp.worldSize = 6000.0f;
	defaultimp.inputScale = 300;
	defaultimp.minBatchSize = 33;
	defaultimp.maxBatchSize = 65;
	// textures
	defaultimp.layerList.resize(3);
	defaultimp.layerList[0].worldSize = 30;
	defaultimp.layerList[0].textureNames.push_back("dirt_grayrocky_diffusespecular.dds");
	defaultimp.layerList[0].textureNames.push_back("dirt_grayrocky_normalheight.dds");
	defaultimp.layerList[1].worldSize = 30;
	defaultimp.layerList[1].textureNames.push_back("grass_green-01_diffusespecular.dds");
	defaultimp.layerList[1].textureNames.push_back("grass_green-01_normalheight.dds");
	defaultimp.layerList[2].worldSize = 30;
	defaultimp.layerList[2].textureNames.push_back("growth_weirdfungus-03_diffusespecular.dds");
	defaultimp.layerList[2].textureNames.push_back("growth_weirdfungus-03_normalheight.dds");
}
//-------------------------------------------------------------------------------------
void HkOgreCharacterDemo::createScene(bool createLevel)
{

	
	// Position it at 500 in Z direction
	getCamera()->setPosition(Ogre::Vector3(0,0,0));
	// Look back along -Z
	getCamera()->lookAt(Ogre::Vector3(0,0,-300));
	//
	/*
	// Uneeded ?
	Ogre::Vector3 lightdir(0.55, -0.3, 0.75);
	lightdir.normalise();
	*/
	Ogre::Light* light = getSceneMgr().createLight("tstLight");
	light->setType(Ogre::Light::LT_POINT);
	light->setDirection(0.4,-0.5,0.5);
	light->setDiffuseColour(Ogre::ColourValue::White);
	light->setSpecularColour(Ogre::ColourValue(0.4, 0.4, 0.4));
	
 
	getSceneMgr().setAmbientLight(Ogre::ColourValue(0.8, 0.8, 0.8));



	if(USE_TERRAIN) {
 
		mTerrainGlobals = OGRE_NEW Ogre::TerrainGlobalOptions();	
	
		// Disable parralax mapping ( weird terrain distortion )
		if(!USE_RTSS){
			Ogre::TerrainGlobalOptions::getSingleton().setDefaultMaterialGenerator(Ogre::TerrainMaterialGeneratorPtr(new Ogre::TerrainMaterialGeneratorA));
			Ogre::TerrainGlobalOptions::getSingleton().setCastsDynamicShadows(true);
			TerrainMaterialGeneratorA::SM2Profile* matProfile = 0;

			matProfile = (TerrainMaterialGeneratorA::SM2Profile*) mTerrainGlobals->getDefaultMaterialGenerator()->getActiveProfile();
			if (matProfile)
			{
				matProfile->setGlobalColourMapEnabled(true);
				matProfile->setCompositeMapEnabled(true);
				matProfile->setLightmapEnabled(true);
				matProfile->setLayerSpecularMappingEnabled(true);
				matProfile->setLayerNormalMappingEnabled(true);
				matProfile->setLayerParallaxMappingEnabled(false);
			}
		}
		else {
			Ogre::TerrainGlobalOptions::getSingleton().setDefaultMaterialGenerator(Ogre::TerrainMaterialGeneratorPtr(new Ogre::TerrainMaterialGeneratorD));
			TerrainMaterialGeneratorD::SM2Profile* matProfile = 0;

			matProfile = (TerrainMaterialGeneratorD::SM2Profile*) mTerrainGlobals->getDefaultMaterialGenerator()->getActiveProfile();
			if (matProfile)
			{
				matProfile->setGlobalColourMapEnabled(false);
				matProfile->setCompositeMapEnabled(false);
				matProfile->setLightmapEnabled(false);
				//matProfile->setLayerSpecularMappingEnabled(false);
				//matProfile->setLayerNormalMappingEnabled(false);
				//matProfile->setLayerParallaxMappingEnabled(false);
			}
		}


		mTerrainGroup = OGRE_NEW Ogre::TerrainGroup(&getSceneMgr(), Ogre::Terrain::ALIGN_X_Z, 513, 12000.0f);
		mTerrainGroup->setFilenameConvention(Ogre::String("BasicTutorial3Terrain"), Ogre::String("dat"));
		mTerrainGroup->setOrigin(Ogre::Vector3(0,-265,0));
 
		configureTerrainDefaults(light);
 
		for (long x = 0; x <= 0; ++x)
			for (long y = 0; y <= 0; ++y)
				defineTerrain(x, y);
 
		// sync load since we want everything in place when we start
		mTerrainGroup->loadAllTerrains(true);
 
		if (mTerrainsImported)
		{
			Ogre::TerrainGroup::TerrainIterator ti = mTerrainGroup->getTerrainIterator();
			while(ti.hasMoreElements())
			{
				Ogre::Terrain* t = ti.getNext()->instance;
				initBlendMaps(t);
			}
		}
		mTerrainGroup->freeTemporaryResources();
		hkpBvTreeShape * bvtree = HK_NULL;
		bvtree = loadBVTreeShape(std::string("terrain.hvk"));
		if(bvtree == HK_NULL) {
			bvtree = HkOgre::Heightfield::processOgreTerrainGroup(mTerrainGroup); // only when using bvtree
			saveBVTreeShape("terrain.hvk", *bvtree);
		}

		// Now that we have a shape all we need is the fixed body to represent it in the 
		// the simulation. Standard rigid body setup.
		hkpRigidBodyCinfo rci;
		rci.m_motionType = hkpMotion::MOTION_FIXED;
		rci.m_position.set(-mTerrainGroup->getTerrainWorldSize() / 2, -265, mTerrainGroup->getTerrainWorldSize() / 2); // only when using heightFieldShape, could be for both
		rci.m_qualityType = HK_COLLIDABLE_QUALITY_FIXED;
		rci.m_shape = bvtree; // only when using bvtree

		//rci.m_friction = 0.6f;

		hkpRigidBody* body = new hkpRigidBody( rci );
		/*
		const hkpShape * shape = body->getCollidableRw()->getShape();
		hkcdShape shapeType = shape->getType();
		if(shapeType.getType() == hkcdShape::ShapeType::BV_TREE) {
			shape->
			*/
		EngineMgr->getHvkWorld()->lock();
		EngineMgr->getHvkWorld()->addEntity(body);
		body->removeReference();		
		
		hkpShapeDisplayBuilder::hkpShapeDisplayBuilderEnvironment env;
		hkpShapeDisplayBuilder builder(env);
		hkArray<hkDisplayGeometry*> displayGeometries;
		builder.buildDisplayGeometries( bvtree, displayGeometries ); // only when using bvtree

		ManualObject *man = getSceneMgr().createManualObject( "CollisionMesh" ); 

		man->begin( "ETTerrainMaterial", RenderOperation::OT_TRIANGLE_LIST );

		Ogre::Vector3 v;

		hkVector4 hv;
		int row, result;

		for(int i = 0; i < displayGeometries.getSize(); i++ )
		{
			hkDisplayGeometry* disp = displayGeometries[i];
			disp->buildGeometry();
			//hkGeometry* geom = disp->getGeometry();
			// geom has all infos which you can directly use to render, see Source\CommonBase\Types\Geometry\hkGeometry.h

			for( int i = 0; i < displayGeometries[0]->getGeometry()->m_triangles.getSize(); i++ )
			{
				for( int j = 0; j <= 1; j++ )
				{
					hv = ( displayGeometries[0]->getGeometry()->getVertex( i, j ) );
					v = HkOgre::Convert::hkVec3toOgre( hv);
					man->position( v );
					man->colour(1,1,1);
				}
				hv = displayGeometries[0]->getGeometry()->getVertex( i, 2 );
				v = HkOgre::Convert::hkVec3toOgre( hv);
				man->position( v );
				man->colour(1,1,1);
			}
		}

		man->end();	
		manNode = getSceneMgr().getRootSceneNode()->createChildSceneNode();
		manNode->attachObject( man );

		hkTransform transform  = body->getTransform();
		v = HkOgre::Convert::hkVec3toOgre( transform.getTranslation());
		manNode->setPosition( Vector3(-mTerrainGroup->getTerrainWorldSize() / 2, -265, mTerrainGroup->getTerrainWorldSize() / 2) ); // only when using heightFieldShape ???
		Ogre::Quaternion q;
		hkQuaternion hq;
		q = HkOgre::Convert::hkQuatToOgre( hq  );

		EngineMgr->getHvkWorld()->unlock();
		manNode->flipVisibility();

		if(USE_PAGED_G){

			//-------------------------------------- LOAD TREES --------------------------------------
			//Create and configure a new PagedGeometry instance
			trees = new PagedGeometry();
			trees->setTempDir("./");
			trees->setCamera(getCamera());	//Set the camera so PagedGeometry knows how to calculate LODs
			trees->setPageSize(80);	//Set the size of each page of geometry
			trees->setInfinite();		//Use infinite paging mode
			
			trees->setBounds(TBounds(0, 0, mTerrainGroup->getTerrainWorldSize(), mTerrainGroup->getTerrainWorldSize()));
			trees->addDetailLevel<BatchPage>(150, 50);		//Use batches up to 150 units away, and fade for 30 more units
			trees->addDetailLevel<ImpostorPage>(500, 50);	//Use impostors up to 400 units, and for for 50 more units

			//Create a new TreeLoader3D object
			treeLoader = new TreeLoader3D(trees, TBounds(0, 0, mTerrainGroup->getTerrainWorldSize(), mTerrainGroup->getTerrainWorldSize()));
			trees->setPageLoader(treeLoader);	//Assign the "treeLoader" to be used to load geometry for the PagedGeometry instance
			
			

			//Load a tree entity
			Entity *myEntity = getSceneMgr().createEntity("Tree", "tree1.mesh");

			//Randomly place 20,00 copies of the tree on each terrain
			Ogre::Vector3 position;
			Ogre::Radian yaw;
			Ogre::Real scale;
			Ogre::TerrainGroup::TerrainIterator ti = mTerrainGroup->getTerrainIterator();
			while(ti.hasMoreElements())
			{
				Ogre::Terrain* t = ti.getNext()->instance;			
				
				for (int i = 0; i < 20000; i++){
					yaw = Ogre::Degree(Math::RangeRandom(0, 360));

					position.x = Ogre::Math::RangeRandom(0, mTerrainGroup->getTerrainWorldSize());
					position.z = Ogre::Math::RangeRandom(0, mTerrainGroup->getTerrainWorldSize());
					position.y = t->getHeightAtWorldPosition(position);

					scale = Math::RangeRandom(0.5f, 0.6f);

					treeLoader->addTree(myEntity, position, yaw, scale);
				}
			}

		}

	}

	CharacterOgre * character = new CharacterOgre("Ogre1", "OgreCam");

	mPlayer = new GameEngine::IPlayer();
	mPlayer->setDefaultControllable(character);
	mPlayer->setActiveControllable(character);

	mPlayer->setCamera(character->getCamera()); // Set the Player's camera to the character's camera
	getRenderWindow()->getViewport(0)->setCamera(mPlayer->getCamera()); // Set Viewport's camera to Player's camera

	//createVehicle();
	// Instead of the default OgreBites camera manager
	// we give control to the awesome Havok follow camera.
	//HkOgre::Vehicle::createCamera( mPlayer->getDefaultControllable()->getAngularFollowCam() );
	
}
//-------------------------------------------------------------------------------------
void HkOgreCharacterDemo::createVehicle()
{
	// Create the basic vehicle.
	// mVehicle = new GameEngine::CVehicle( CAR ); // old method

	// Pointer to Havok World
	hkpWorld * mWorld = EngineMgr->getHvkWorld();

			
	// create a Controllable Vehicle
	mVehicle = new GameEngine::IVehicle("Vehicle1",CAR);

	VehicleSetup setup;
	EngineMgr->getHvkWorld()->markForRead();
	setup.buildVehicle( mWorld, *mVehicle->getVehicleInstance());
	mWorld->unmarkForRead();
	mWorld->markForWrite();
	mVehicle->getVehicleInstance()->addToWorld( mWorld );
	
	/// Actions are the interface between user controllable behavior of the physical simulation and the Havok core. 
	/// You can easily integrate the Vehicle Kit with the Havok physical simulation using the hkpVehicleInstance action, 
	/// which establishes the connection between the two SDKs. 
	///
	///	To simulate a vehicle, you first need to create a hkpVehicleInstance instance in your game. 
	/// You then add it to the actions of your core physical simulation, just like any other user action:

	mWorld->addAction(mVehicle->getVehicleInstance());
	
	///>
	/// Once you have added the action to the simulation, no extra work is required to simulate the vehicle. 
	/// On each call to step the core physical simulation, the vehicle action will be updated automatically.
	///>
	mWorld->unmarkForWrite();
}

//-------------------------------------------------------------------------------------
bool HkOgreCharacterDemo::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	//[NOTE] PagedGeometry::update() is called every frame to keep LODs, etc. up-to-date
	trees->update();

	mPlayer->getActiveControllable()->addTime(evt.timeSinceLastFrame);
	GameEngine::ControllableFactory::ControllableMap controllables = GameEngine::EngineManager::getInstance()->getControllableFactory()->getControllables();
	for(GameEngine::ControllableFactory::ControllableMap::iterator iter = controllables.begin(); iter != controllables.end(); iter++) {
		if(iter->second != mPlayer->getActiveControllable()) {
			(iter)->second->addTime(evt.timeSinceLastFrame);
			(iter)->second->updateAnimations(evt.timeSinceLastFrame);
			(iter)->second->updateBody(evt.timeSinceLastFrame);
			(iter)->second->updatePhysics(evt.timeSinceLastFrame);
		}
	}

	// Update the Havok world if initialized
	if (EngineMgr->isHvkInitialized())
	{
		if (evt.timeSinceLastFrame > 0)
			EngineMgr->getHvkWorld()->stepMultithreaded( EngineMgr->gethkJobQueue(), EngineMgr->gethkJobThreadPool(), evt.timeSinceLastFrame);//1 / 60.0f );
			//mWorld->stepDeltaTime(evt.timeSinceLastFrame);

		// Step the visual debugger. We first synchronize the timer data
		EngineMgr->gethkpPhysicsContext()->syncTimers( EngineMgr->gethkJobThreadPool() );
		EngineMgr->gethkVisualDebugger()->step();

		// Clear accumulated timer data in this thread and all slave threads
		hkMonitorStream::getInstance().reset();
		EngineMgr->gethkJobThreadPool()->clearTimerData();
	}

	// Return the result of the base application event.
	return BaseApplication::frameRenderingQueued(evt);
}
//-------------------------------------------------------------------------------------
bool HkOgreCharacterDemo::keyPressed( const OIS::KeyEvent &evt )
{
	/*
	if(evt.key == OIS::KC_RETURN && mPlayer->isInVehicle()) {
		mPlayer->exitVehicle();
	}
	else if(evt.key == OIS::KC_RETURN && !mPlayer->isInVehicle()) {
		mPlayer->enterVehicle(mVehicle);
	}
	*/
	if( evt.key== OIS::KC_P ) manNode->flipVisibility();
	if( evt.key== OIS::KC_O ) mTerrainGroup->unloadTerrain(0,0);
	if( evt.key== OIS::KC_I ) mTerrainGroup->loadAllTerrains();
	
	//mPlayer->getInputHandler()->mapUserInput(getPlayer()->getTranslator()->getMappedKey(evt.key),KEYDOWN);
	//IInputMessage message = ;
	mPlayer->sendInputMessage(mPlayer->getInputTranslator()->getInputMessage(evt.key), KEYDOWN);
	return BaseApplication::keyPressed(evt);
}
//-------------------------------------------------------------------------------------
bool HkOgreCharacterDemo::keyReleased( const OIS::KeyEvent &evt )
{
	//mPlayer->getInputHandler()->mapUserInput(getPlayer()->getTranslator()->getMappedKey(evt.key),KEYUP);
	//mPlayer->getActiveControllable()->injectKeyUp(evt);
	mPlayer->sendInputMessage(mPlayer->getInputTranslator()->getInputMessage(evt.key), KEYUP);
	return BaseApplication::keyReleased(evt);
}
//-------------------------------------------------------------------------------------
bool HkOgreCharacterDemo::mouseMoved( const OIS::MouseEvent &evt )
{
	IControllable * controllable = mPlayer->getActiveControllable();
	mPlayer->getActiveControllable()->injectMouseMove(evt);
	return BaseApplication::mouseMoved(evt);
}
//-------------------------------------------------------------------------------------
bool HkOgreCharacterDemo::mousePressed( const OIS::MouseEvent &evt, OIS::MouseButtonID id )
{
	// Ignore the default ball-shooting behavior.
	mPlayer->getActiveControllable()->injectMouseDown(evt, id);

	//    GameEngine::Globals::getInstance()->getCameraMan()->injectMouseDown(arg, id);

	const hkReal radius = 1.f;
	const hkReal sphereMass = 150.0f;

	hkpRigidBodyCinfo info;
	hkpMassProperties massProperties;
	hkpInertiaTensorComputer::computeSphereVolumeMassProperties(radius, sphereMass, massProperties);

	info.m_mass = massProperties.m_mass;
	info.m_centerOfMass  = massProperties.m_centerOfMass;
	info.m_inertiaTensor = massProperties.m_inertiaTensor;
	info.m_shape = new hkpSphereShape( radius );
	info.m_position = HkOgre::Convert::ogreVec3ToHk(getCamera()->getDerivedPosition());
	info.m_motionType  = hkpMotion::MOTION_BOX_INERTIA;
	info.m_qualityType = HK_COLLIDABLE_QUALITY_BULLET;

	hkpRigidBody* sphereRigidBody = new hkpRigidBody( info );

	Ogre::SceneNode* sphereNode = getSceneMgr().getRootSceneNode()->createChildSceneNode();
	sphereNode->attachObject(getSceneMgr().createEntity("defSphere.mesh"));

	HkOgre::Renderable* rend = new HkOgre::Renderable(sphereNode, sphereRigidBody, EngineMgr->getHvkWorld());

	sphereRigidBody->setLinearVelocity(HkOgre::Convert::ogreVec3ToHk(getCamera()->getRealDirection() * 30));

	EngineMgr->getHvkWorld()->markForWrite();
	EngineMgr->getHvkWorld()->addEntity(sphereRigidBody)->removeReference();
	info.m_shape->removeReference();
	EngineMgr->getHvkWorld()->unmarkForWrite();

	return true;
}
